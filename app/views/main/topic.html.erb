<% provide(:in_topic, true) -%>
<% provide(:topic_name, @topic ? @topic.name : "Uncategorized") -%>
<% provide(:indicators, @indicators) -%>
<div class=stream id=stream>
    <div class=backlog_area id=backlog_area>
        <% if @posts and @posts.length >= MainController::PPP -%>
        <button class=backlog_button type=button onClick="request_backlog()">Backlog</button>
        <% end -%>
    </div>
    <div class=error_area id=backlog_error></div>
    <div class=post_list id=stream_post_list>
    <% for p in @posts -%>
        <%= render 'post/view', post: p, pinned: false, user: @user %>
    <% end -%>
    </div>
    <div class=error_area id=update_error></div>
    <div class=new_post_form id=stream_post_form>
    <%= form_tag('/post/new') do -%>
        <textarea name=content tabindex=1 id=new_post_content autofocus></textarea>
        <button type=submit tabindex=2 id=new_post_submit>Post</button>
        <% if @topic -%>
            <input type=hidden name=topic value="<%= @topic.id %>"/>
        <% end -%>
    <% end -%>
    </div>
    <br>
</div>
<div class=pinned_posts>
    <div class=post_list id=pinned_post_list>
    <% for p in @pinned -%>
        <%= render 'post/view', post: p, pinned: true, user: @user %>
    <% end -%>
    </div>
</div>
<script>
    var stream = document.getElementById('stream');
    var stream_post_list = document.getElementById('stream_post_list');
    var pinned_post_list = document.getElementById('pinned_post_list');
    var update_error = document.getElementById('update_error');
    var backlog_area = document.getElementById('backlog_area');
    var backlog_error = document.getElementById('backlog_error');
    var new_post_content = document.getElementById('new_post_content');
    var showing_post = null;
    var update_delay = 4000;
    <% lastpost = Post.last -%>
    var latest = <%= lastpost ? lastpost.id : 0 %>;
    var earliest = <%= @posts.first.id %>;

    function scroll_stream () {
        stream.scrollTop = stream.scrollHeight;
    }
    scroll_stream();

    function unshow_post () {
        if (showing_post) {
            showing_post.className = showing_post.className.replace(/(\s|^)showing(\s|$)/, ' ');
        }
        showing_post = null;
    }
    function show_post (ref) {
        var pinned = document.getElementById("pinned_" + parseInt(ref));
        if (pinned) {
            if (pinned == showing_post) {
                unshow_post();
            }
            else {
                pinned.scrollIntoView(true);
                pinned.className += " showing";
                if (showing_post) unshow_post();
                showing_post = pinned;
            }
        }
        else {
            var post = document.getElementById("post_" + parseInt(ref));
            if (post) {
                if (post == showing_post) {
                    unshow_post();
                }
                else {
                    post.scrollIntoView(true);
                    post.className += " showing";
                    if (showing_post) unshow_post();
                    showing_post = post;
                }
            }
            else {
                unshow_post();
            }
        }
    }
    function reply_to_post (ref) {
        new_post_content.value += ">>" + parseInt(ref) + "  ";
    }

    function handle_update () {
        if (this.readyState == this.DONE) {
            if (this.status == 200) {
                if (this.responseXML != null) {
                    html = this.responseXML;
                    var new_posts = html.getElementById("new_posts");
                    if (new_posts == null) {
                        make_error(update_error, "Update error: The server didn't include new_posts");
                        return;
                    }
                    var wants_scroll = (stream.scrollTop > stream.scrollHeight - stream.offsetHeight - 120);
                     // Update posts
                    var added_posts = false;
                    while (new_posts.firstChild != null) {
                        post = new_posts.firstChild;
                        if (post.nodeType == post.ELEMENT_NODE) {
                            added_posts = true;
                            var event_match = post.className.match(/(\s|^)this_(.*)_(.*)(\s|$)/);
                            make_error(event_match);
                            if (event_match) {
                                if (event_match[2] == "pins") {
                                    var pinned = document.getElementById("post_" + event_match[3]);
                                    if (pinned) {
                                        pinned.className += " pinned";
                                        pinned_pinned = pinned.cloneNode();
                                        pinned_pinned.id = "pinned_" + event_match[3];
                                        pinned_post_list.appendChild(pinned_pinned);
                                    }
                                }
                                else if (event_match[2] == "unpins") {
                                    var pinned_unpinned = document.getElementById("pinned_" + event_match[3]);
                                    if (pinned_unpinned) {
                                        pinned_post_list.removeChild(pinned_unpinned);
                                    }
                                    var unpinned = document.getElementById("post_" + event_match[3]);
                                    if (unpinned) {
                                        unpinned.className = unpinned.className.replace(/(\s|^)pinned(\s|$)/, ' ');
                                    }
                                }
                                else if (event_match[2] == "yells") {
                                    var yelled = document.getElementById("post_" + event_match[3]);
                                    if (yelled) yelled.className += " yelled";
                                    var pinned_yelled = document.getElementById("pinned_" + event_match[3]);
                                    if (pinned_yelled) pinned_yelled.className += " yelled";
                                }
                                else if (event_match[2] == "unyells") {
                                    var unyelled = document.getElementById("post_" + event_match[3]);
                                    if (unyelled)
                                        unyelled.className = unyelled.className.replace(/(\s|^)yelled(\s|$)/, ' ');
                                    var pinned_unyelled = document.getElementById("pinned_" + event_match[3]);
                                    if (pinned_unyelled)
                                        pinned_unyelled.className = pinned_unyelled.className.replace(/(\s|^)yelled(\s|$)/, ' ');
                                }
                            }
                        }
                        stream_post_list.appendChild(post);
                    }
                     // Update latest post id
                    new_latest = html.getElementById("new_latest");
                    if (new_latest != null) latest = parseInt(new_latest.textContent);
                     // Update indicators
                    var new_indicators = html.getElementById("new_indicators");
                    if (new_indicators) {
                        var inds = new_indicators.textContent.match(/\S+/g);
                        if (inds) {
                            for (var i = 0; i < inds.length; i++) {
                                var tab = document.getElementById("indicator_" + inds[i]);
                                if (tab) tab.className += ' activity';
                            }
                        }
                    }
                     // Set new timeout
                    if (added_posts) update_delay = 4000;
                    else if (update_delay < 32000) update_delay += 4000;
                    setTimeout( "request_update()", update_delay );
                     // Scroll to bottom
                    if (wants_scroll && added_posts) scroll_stream();
                }
                else {
                    make_error(update_error, "Update error: The server didn't response with valid XML");
                    return;
                }
            }
            else if (this.status != 0) {
                make_error(update_error, "Update error: The server returned " + this.status);
                return;
            }
        }
    }

    function handle_backlog () {
        if (this.readyState == this.DONE) {
            if (this.status == 200) {
                if (this.responseXML != null) {
                    html = this.responseXML;
                    var old_posts = html.getElementById("old_posts");
                    if (old_posts == null) {
                        make_error(backlog_error, "Backlog error: The server didn't include old_posts");
                        return;
                    }
                    while (old_posts.lastChild != null) {
                        post = old_posts.lastChild;
                        stream_post_list.insertBefore(post, stream_post_list.firstChild);
                    }
                    var new_earliest = html.getElementById("new_earliest");
                    if (new_earliest != null)
                        earliest = parseInt(new_earliest.textContent);
                    else
                        backlog_area.textContent = "";

                }
                else {
                    make_error(backlog_error, "Backlog error: The server didn't response with valid XML");
                    return;
                }
            }
            else if (this.status != 0) {
                make_error(backlog_error, "Backlog error: The server returned " + this.status);
                return;
            }
        }
    }

    function make_error (loc, mess) {
        loc.textContent = mess;
    }
    function clear_error (loc) {
        loc.textContent = "";
    }
    function request_update () {
        var client = new XMLHttpRequest();
        client.onreadystatechange = handle_update;
        <% if @topic -%>
        client.open("GET", "/main/update.xml?topic=<%= @topic.id %>&since=" + latest);
        <% else -%>
        client.open("GET", "/main/update.xml?since=" + latest);
        <% end -%>
        client.send();
    }
    setTimeout( "request_update()", update_delay );
    function request_backlog () {
        clear_error(backlog_error);
        var client = new XMLHttpRequest();
        client.onreadystatechange = handle_backlog;
        <% if @topic -%>
        client.open("GET", "/main/backlog.xml?topic=<%= @topic.id %>&before=" + earliest);
        <% else -%>
        client.open("GET", "/main/backlog.xml?before=" + earliest);
        <% end -%>
        client.send();
    }
</script>
